---
output: html_document
---

# Introduction to R

> R is an interpreted programming language that is majorly used in the scientific domain.
> It is widely used among statisticians and data miners.

## Basics

### Comments

Comments start with a `#`. Anything that comes after a `#` is ignored by R. These are used to document the code being written

```{r}
# Booga booga
# Namaskara
```

### Integers

```{r}
4L+2L
```

### Strings

```{r}
"Hello World"
```

### Floats

```{r}
4.2
```

### Logical

```{r}
TRUE
FALSE
```


## Arithmatic

- Additions with `+` 
    ```{r}
    40 + 2
    ```

- Subtractions with `-`
    ```{r}
    44 - 2
    ```


- Multiplications with `*`
    ```{r}
    21 * 2    
    ```

- Divisions with `/`
    ```{r}
    84 / 2
    ```


- Exponentiation with `^`
    ```{r}
    7 ^ 8
    ```


- Modulo with `%%`
    ```{r}
    71 %% 5
    ```

## Variables & Assignment

Use the `<-` operator to assign values to variables. An Integer, a string or a floating point number can be assigned.

```{r}
answer_to_life <- 42
```

To print, simply use the name of the variable

```{r}
answer_to_life
```

All arithmatic operations are supported on variables

```{r}
foo <- 21
bar <- 21
```

```{r}
answer_to_life <- foo + bar
answer_to_life
```

## Types?

The `class` function can be used to identify the underlying type of a variable or literal

```{r}
class(42L)
class(42.0)
class("Fourty Two")
```

---

### [ Exercise ]

What is the type of `TRUE` and `FALSE` ? 

```{r}
# Answer here
```

---

## Vectors

Vectors are one dimensional arrays that can hold **one** type of data. The `c` function allows us to create a vector out of provided values

Let us say we want to express the amount of Kilometers that we have run in the past 5 days. We can use a vector for this.

```{r}
kms_run <- c(4.0, 5.2, 6.0, 5.2, 5.0)
kms_run
```

We can also use it to track which all days of the week we ran

```{r}
did_run <- c(TRUE, TRUE, FALSE, TRUE, FALSE)
did_run
```

---

### [ Exercise ]

For some analysis, let us put together the amount of kilometers that we have run over the past 2 weeks. The last week, we ran: 

Day of week | Kilometers
----------- | ------------
Monday      | 4
Tuesday     | 5.2
Wednesday   | 6
Thursday    | 5.2
Friday      | 5

This is expressed as the vector

```{r}
kms_last_week <- c(4.0, 5.2, 6.0, 5.2, 5.0)
```

This week, we ran:

Day of week | Kilometers
----------- | ------------
Monday      | 6
Tuesday     | 6.2
Wednesday   | 6
Thursday    | 7.2
Friday      | 7.5

Populate this in a vector `kms_this_week`

```{r eval=FALSE}
kms_this_week <- # Answer here
```

---

When we're looking at a vector, it makes more sense if we can somehow name all the values, right? 

We can provide names to the elements of a vector with the `names` function.

Consider the amount of kilometers that we ran in the last week

```{r}
kms_last_week <- c(4.0, 5.2, 6.0, 5.2, 5.0)
kms_last_week
```

Just looking at `kms_last_week` can become confusing. Let us use the `names` function to give each element the day of the week

```{r}
names(kms_last_week) <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
```

Now, the data can stand independently and is much more clearer

```{r}
kms_last_week
```

Note that we're assigning a vector when we're giving names. So instead of repeating it multiple times, we can reuse the vector as well 

```{r}
days_of_week <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
names(kms_last_week) <- days_of_week
```

### Vector arithmatic

Arithmatic can be performed on vectors. Let us calculate the total amount of kilometers that we ran on each day in the past 2 weeks 

```{r}
kms_last_week <- c(4.0, 5.2, 6.0, 5.2, 5.0)
kms_this_week <- c(6.0, 6.2, 6.0, 7.2, 7.5)

total_kms_past_2_weeks <- kms_last_week + kms_this_week
total_kms_past_2_weeks
```

But how many kilometers did we run totally in each week? Sum each of the vectors using the `sum` function - simple, no?

```{r}
distance_last_week <- sum(kms_last_week)
distance_last_week
```

```{r}
distance_this_week <- sum(kms_this_week)
distance_this_week
```

---

### [ Exercise ]

1. Assign days of the week names to the `total_kms_past_2_weeks` vector using the `names` function.

    ```{r}
    # Answer here
    ```

2. What is the total distance we ran across both weeks? Use the `total_kms_past_2_weeks` vector to arrive at your answer

    ```{r}
    # Answer here
    ```

---

### Vector element selection

Consider the `total_kms_past_2_weeks` vector. Let us say that we want to get the distance we ran across both weeks, on wednesday

```{r}
total_kms_past_2_weeks
```

We know that wednesday is the 3rd day of the week, So we pick up the **3rd** element from the vector like so:

```{r}
total_kms_past_2_weeks[3]
```

**Note:** A very important thing to note here is that R begins its indexing from `1` and not `0` unlike most other programming languages.

What if we're interested in a section of results, say our performance as the week comes to an end (wednesday, thursday, friday).

We can provide a vector of required indices like so:

```{r}
total_kms_past_2_weeks[c(3,4,5)]
```

But say we have 100 elements in the vector, it would soon become tedious if we want to select a range, say from 50-72 or from 44-62, right? To solve this problem, R provides us with the range operator - `:` which we takes a starting number and an ending numer and returns a vector containing all those numbers. We can then use this to fetch required elements.

Let us look at the range operator first.

```{r}
1:5
```

---

### [ Exercise ]

Use the Range operator (`:`) to fetch the Monday - Wednesday section in the `total_kms_past_2_weeks` vector

```{r}
# Answer here
```

---

Also, since we've given names to the vector elements, we can use those names to seek to the elements instead of using indexes.

```{r}
names(total_kms_past_2_weeks) <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
total_kms_past_2_weeks["Wednesday"]
total_kms_past_2_weeks[c("Monday", "Tuesday")]
```

We can also perform logical operations on vectors. Let us check to see on how many days in the last week, we ran more than 4 kilometers

```{r}
kms_last_week <- c(4.0, 5.2, 6.0, 5.2, 5.0)

days_of_week <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
names(kms_last_week) <- days_of_week

days_more_than_5 <- kms_last_week > 5
days_more_than_5
```

We can use logical operations in combination with the vector to select only those elements from a vector that match a condition.

Now that `days_more_than_5` contain a list of days where we ran more than 5 kilometers, let us select _just_ those items into another vector

```{r}
kms_last_week <- c(4.0, 5.2, 6.0, 5.2, 5.0)

days_of_week <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
names(kms_last_week) <- days_of_week

days_more_than_5 <- kms_last_week > 5

kms_last_week[days_more_than_5]
```

## Factors

Usually, most data is catagorical. Meaning that data can usually be put into catagories.

Let's start with something simple. Training for runs happens in 2 forms:

- Interval based training, where you focus on speed 
- Distance based training, where the focus is on endurance

Take a vector that represents all the days we did intervals / distance in the last 10 days. There are some days where we rest as well.

```{r}
running_style <- c("INT", "INT", "DIST", "DIST", "DIST", "REST", "INT", "DIST", "DIST", "DIST")
names(running_style) <- 1:10
running_style
```

As you see, we can divide our runs into **categories**. Factors are used to represent these categories. Let us use the `factor` function to extract the factors out of this vector

```{r}
running_style.f = factor(running_style)
running_style.f
```

Perfect, this tells us that we have 3 `level`s, i.e. we indeed have 3 running styles. 

We can confirm that `running_style.f` is indeed a factor variable by checking its underlying type with the `class function`

```{r}
class(running_style.f)
```

Once we have our `level`s, we can modify them to our suiting with the `levels` function (very similar to the `names` function)

```{r}
levels(running_style.f)
levels(running_style.f) <- c("Endurance", "Speed", "Rest")
levels(running_style.f)
```

This also gives us access to a new function - `summary` which gives us a summary of the data

```{r}
summary(running_style.f)
```

This quickly tells us that out of the 10 days we ran, on 6 we did distance runs, 3 were interval runs and we took 1 day of rest.

### Types of factor variables

As said, `Factor` allow us to create _categorical_ variables. These variables can be of 2 types:

- Nominal
- Ordinal

#### Nominal Variables

By default a factor is nominal. Meaning that it picks categories by name and without any assigned order. So trying a logical `<` or `>` operation against them won't yield us anything

```{r}
running_style.f = factor(running_style)
running_style.f[1] > running_style.f[2]
```

As you see, it yields us a "`>` not meaningful for factors" error

#### Ordinal Variables

Passing a `order=TRUE` argument to `factor` will make the factor into an ordinal variable and `<` and `>` are meaningful here. 

Consider the amount of kilometers run in the past 10 days

```{r}
kms_run <- c(4.0, 5.2, 6.0, 5.2, 5.0, 6.0, 6.2, 6.0, 7.2, 7.5)
```

Lets classify this into Long, Medium and Short runs manually

```{r}
distance_type <- c("S", "M", "M", "M", "M", "M", "M", "M", "L", "L")
```

Now we can pick up factors from this, but we understand an order here. Short < Medium < Long. To introduce an order, we need to pass the `order=TRUE` and pass the right order of the `levels` we require. 

```{r}
distance_type.f = factor(distance_type, order=TRUE, levels=c("S", "M", "L"))
distance_type.f
```

If you notice, you'll see the order being represented. `S < M < L` in this case.

Now that we have an order in place, we can use `<` and `>`

```{r}
distance_type.f[1]
distance_type.f[2]
distance_type.f[1] > distance_type.f[2]
```

The real reason why factors are important will be covered in forthcoming sessions. This just introduces the concept and the necessity for it.